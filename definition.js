// Generated by CoffeeScript 2.0.2
(function() {
  /* CLASS */
  /* ACTION */
  /* FORMATERS */
  /* OPERATORS */
  /* NODES TYPES */
  var GLOBAL, Node, Tape, actions, formaters, instructions, op, parseBinary, tape, types;

  Tape = class Tape {
    // create a new TAPE
    constructor() {
      console.log("TAPE CREATED!");
    }

    // initialize the tape with the define instruction
    init(type) {
      // used to store the data
      this.array = (function() {
        switch (type) {
          case 8:
            return new Uint8Array(0x100);
          case -8:
            return new Int8Array(0x100);
          case 16:
            return new Uint16Array(0x10000);
          case -16:
            return new Int16Array(0x10000);
        }
      })();
      // used for keeping numbers in the expected range
      this.byte = (function() {
        switch (type) {
          case 8:
            return new Uint8Array(1);
          case -8:
            return new Int8Array(1);
          case 16:
            return new Uint16Array(1);
          case -16:
            return new Int16Array(1);
        }
      })();
      // used to correctly index the array
      return this.index = (function() {
        switch (Math.abs(type)) {
          case 8:
            return new Uint8Array(1);
          case 16:
            return new Uint16Array(1);
        }
      })();
    }

    
    // convert to the numerical type chosen
    convert(x) {
      this.byte[0] = x;
      return this.byte[0];
    }

    
    // set the value in the array
    set(i, x) {
      this.index[0] = i;
      this.array[this.index[0]] = x;
      return null;
    }

    
    // get the value from the array
    get(i) {
      this.index[0] = i;
      return this.array[this.index[0]];
    }

    // increment and decrement a value
    incr(i) {
      this.index[0] = i;
      return ++this.array[this.index[0]];
    }

    decr(i) {
      this.index[0] = i;
      return --this.array[this.index[0]];
    }

  };

  // we need an instance of tape
  tape = new Tape();

  op = {};

  // unary
  op.AT = function(i) {
    return tape.get(i);
  };

  op.NOT = function(a) {
    if (!a) {
      return 0;
    } else {
      return 1;
    }
  };

  op.BNOT = function(a) {
    return tape.convert(~a);
  };

  op.INCR = function(a) {
    return tape.convert(a + 1);
  };

  op.DECR = function(a) {
    return tape.convert(a - 1);
  };

  op.INCR_ = function(i) {
    return tape.incr(i);
  };

  op.DECR_ = function(i) {
    return tape.decr(i);
  };

  op.ABS = function(a) {
    return tape.convert(Math.abs(a)); // special case |-128| -> 128 > 127 -> -128
  };

  op.NEG = function(a) {
    return tape.convert(-a); // we may have only positive numbers
  };

  // arithmetic
  op.ADD = function(a, b) {
    return tape.convert(a + b);
  };

  op.SUB = function(a, b) {
    return tape.convert(a - b);
  };

  op.MUL = function(a, b) {
    return tape.convert(a * b);
  };

  op.DIV = function(a, b) {
    return tape.convert(a / b); // if b == 0 -> 0
  };

  op.MOD = function(a, b) {
    return tape.convert(a % b);
  };

  
  // logical
  op.AND = function(a, b) {
    if (a && b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.OR = function(a, b) {
    if (a || b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.XOR = function(a, b) {
    if (!a !== !b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.NAND = function(a, b) {
    if (a && b) {
      return 0;
    } else {
      return 1;
    }
  };

  op.NOR = function(a, b) {
    if (a || b) {
      return 0;
    } else {
      return 1;
    }
  };

  op.XNOR = function(a, b) {
    if (!a !== !b) {
      return 0;
    } else {
      return 1;
    }
  };

  // bitwise
  op.BAND = function(a, b) {
    return tape.convert(a & b);
  };

  op.BOR = function(a, b) {
    return tape.convert(a | b);
  };

  op.BXOR = function(a, b) {
    return tape.convert(a ^ b);
  };

  op.BNAND = function(a, b) {
    return tape.convert(~(a & b));
  };

  op.BNOR = function(a, b) {
    return tape.convert(~(a | b));
  };

  op.BXNOR = function(a, b) {
    return tape.convert(~(a ^ b));
  };

  op.LSHIFT = function(a, b) {
    return tape.convert(a << b);
  };

  op.RSHIFT = function(a, b) {
    return tape.convert(a >> b);
  };

  // comparator
  op.EQU = function(a, b) {
    if (a === b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.DIF = function(a, b) {
    if (a !== b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.GRT = function(a, b) {
    if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.LST = function(a, b) {
    if (a < b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.GTE = function(a, b) {
    if (a >= b) {
      return 1;
    } else {
      return 0;
    }
  };

  op.LSE = function(a, b) {
    if (a <= b) {
      return 1;
    } else {
      return 0;
    }
  };

  actions = {};

  // wait the given number of milliseconds before continuing
  actions.WAIT = function(v, f) {
    setTimeout(f, v);
    return null;
  };

  // play a bell sound of given note
  actions.BELL = function(v, s) {
    s.Play();
    return null;
  };

  // display the value in the console
  actions.DISPLAY = function(v) {
    return console.log(v);
  };

  // print the character in the console
  actions.PRINT = function(v) {
    return console.log(v);
  };

  types = {};

  // classes that define the nodes of our AST
  Node = class Node {
    print() {
      return "Node undefined";
    }

  };

  // change the value of a cell
  types.Assign = class Assign extends Node {
    constructor(cell, value1) {
      super();
      this.cell = cell;
      this.value = value1;
    }

    print() {
      return `at ${this.cell} assign ${this.value.print()}`;
    }

  };

  types.Increment = class Increment extends Node {
    constructor(cell) {
      super();
      this.cell = cell;
    }

    print() {
      return `increment value at ${this.cell}`;
    }

  };

  types.Decrement = class Decrement extends Node {
    constructor(cell) {
      super();
      this.cell = cell;
    }

    print() {
      return `decrement value at ${this.cell}`;
    }

  };

  // navigate through the program
  types.Flag = class Flag extends Node {
    constructor(id) {
      super();
      this.id = id;
    }

    print() {
      return `flag ${this.id.print()}`;
    }

  };

  types.Goto = class Goto extends Node {
    constructor(id) {
      super();
      this.id = id;
    }

    print() {
      return `go to flag ${this.id.print()}`;
    }

  };

  // do an action
  types.Action = class Action extends Node {
    constructor(action, value1) {
      super();
      this.action = action;
      this.value = value1;
    }

    print() {
      return "do action {@action} with value {@value}";
    }

  };

  // apply operations to values
  types.Monadic = class Monadic extends Node {
    constructor(op1, expr) {
      super();
      this.op = op1;
      this.expr = expr;
    }

    print() {
      return `operate ${this.op} on ${this.expr}`;
    }

  };

  types.Dyadic = class Dyadic extends Node {
    constructor(op1, left, right) {
      super();
      this.op = op1;
      this.left = left;
      this.right = right;
    }

    print() {
      return `operate ${this.op} on ${this.left.print()} and ${this.right.print()}`;
    }

  };

  // conditional
  types.If = class If extends Node {
    constructor(conds, blocks) {
      super();
      this.conds = conds;
      this.blocks = blocks;
    }

    print() {
      var block, cond, j, len, ref, strings;
      strings = [];
      ref = zip(this.conds, this.blocks);
      for (j = 0, len = ref.length; j < len; j++) {
        [cond, block] = ref[j];
        strings.push(`if ${cond.print()} then do ${block.print()} \n`);
      }
      return strings.join();
    }

  };

  // loop
  types.Loop = class Loop extends Node {
    constructor(cond1, block1, breaks1) {
      super();
      this.cond = cond1;
      this.block = block1;
      this.breaks = breaks1;
    }

    print() {
      return `loop while ${this.cond.print()} and do ${block.print()}`;
    }

  };

  types.Break = class Break extends Node {
    constructor(isStop) {
      super();
      this.isStop = isStop;
    }

    print() {
      return `stop the loop ${this.loop}`;
    }

  };

  formaters = {};

  instructions = [];

  // program structure
  formaters._program = function(def, instrs) {
    instructions.push(...instrs);
    return instrs;
  };

  formaters._define = function(value) {
    tape.init(value);
    return null;
  };

  formaters._instructions = function(instrs, instr) {
    instrs = instrs || [];
    instrs.push(instr);
    return instrs;
  };

  // change values
  formaters._incr = function(type, value) {
    switch (type) {
      case 0:
        return new types.Monadic(op.INCR, value);
      case 1:
        return new types.Monadic(op.INCR_, value);
    }
  };

  formaters._decr = function(type, value) {
    switch (type) {
      case 0:
        return new types.Monadic(op.DECR, value);
      case 1:
        return new types.Monadic(op.DECR_, value);
    }
  };

  
  // conditionals
  formaters._if = function(cond, block, elses) {
    if (elses != null) {
      elses.conds.unshift(cond);
      elses.blocks.unshift(block);
    } else {
      return new types.If([cond], [block]);
    }
    return new types.If(elses.conds, elses.blocks);
  };

  formaters._elseif = function(cond, block, elses) {
    if (elses != null) {
      elses.conds.unshift(cond);
      elses.blocks.unshift(block);
    } else {
      return {
        conds: [cond],
        blocks: [block]
      };
    }
    return elses;
  };

  formaters._else = function(block) {
    return {
      conds: [null],
      blocks: [block]
    };
  };

  // loops
  formaters._loop = function(cond, block) {
    var breaks;
    // TODO: look for stops and retries in the inner block
    breaks = [];
    return new types.Loop(cond, block, breaks);
  };

  // parse the numbers
  parseBinary = function(string) {
    return parseInt(string);
  };

  formaters._number = function(type, value) {
    switch (type) {
      case "decimal":
        return parseInt(value);
      case "octal":
        return parseInt('0' + value);
      case "hexadecimal":
        return parseInt('0x' + value);
      case "binary":
        return parseBinary(value);
      default:
        return 0;
    }
  };

  // store our functions into the global scope
  GLOBAL = window || exports;

  GLOBAL.TAPE = {tape, op, types, formaters, actions, instructions};

}).call(this);
