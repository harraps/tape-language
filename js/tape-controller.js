// Generated by CoffeeScript 2.3.1
(function() {
  /* ACTIONS */
  /*
  	for actions 'bell' and 'print', it is necessary to provide a callback
  	function to 'TAPE' because their implementation may vary from one platform
  	to another.
  */
  /* CORRECTOR */
  /* FORMATERS */
  /* MEMORY TYPES */
  /* NODES TYPES */
  /* OPERATORS */
  var GLOBAL, Node, action, corrector, find_breaks, formater, memory, node, op, str_block, str_node, str_tabs,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  action = {
    // wait the given number of milliseconds before continuing
    wait: function(v) {
      // tape 16-bits : milliseconds
      // tape  8-bits : seconds
      return new Promise(function(resolve) {
        return window.setTimeout(resolve, TAPE.corrector.time(v));
      });
    },
    // play a bell sound of given note
    bell: function(v) {
      return typeof TAPE.playSound === "function" ? TAPE.playSound(TAPE.corrector.pitch(v)) : void 0;
    },
    // print the character in the console
    print: function(v) {
      return typeof TAPE.printChar === "function" ? TAPE.printChar(String.fromCharCode(TAPE.corrector.unsign(v))) : void 0;
    }
  };

  corrector = {
    // cells to perform value correction
    sCell: null, //   signed cell
    uCell: null, // unsigned cell
    
    // centiseconds
    timeUnit: 10,
    // indexed frequencies
    frequencies: [
      440.00, // A
      466.16, // A#
      493.88, // B
      523.25, // C
      554.37, // C#
      587.37, // D
      622.25, // D#
      659.25, // E
      698.46, // F
      739.99, // F#
      783.99, // G
      830.61 // G#
    ],
    // initialize the corrector with the program type
    init: function(type) {
      if (type === 16) {
        this.timeUnit = 1; // milliseconds
        this.frequencies = null; // full range of frequencies
        this.sCell = new Int16Array(1);
        return this.uCell = new Uint16Array(1);
      } else {
        this.sCell = new Int8Array(1);
        return this.uCell = new Uint8Array(1);
      }
    },
    // signed correction
    sign: function(v) {
      this.sCell[0] = v;
      return this.sCell[0];
    },
    // unsigned correction
    unsign: function(v) {
      this.uCell[0] = v;
      return this.uCell[0];
    },
    // value correction for timed function
    time: function(n) {
      this.uCell[0] = n;
      return this.uCell[0] * this.timeUnit;
    },
    // value correction for audio player
    pitch: function(n) {
      var l;
      this.sCell[0] = n;
      if (this.frequencies != null) {
        n = this.sCell[0];
        l = this.frequencies.length;
        return this.frequencies[modulo(n, l)] * Math.pow(2, Math.floor(n / l));
      }
      return this.sCell[0];
    }
  };

  formater = {
    // program structure
    program: function(def, funcs) {
      var program;
      TAPE.corrector.init(def);
      program = new TAPE.node.Program(def, funcs);
      TAPE.program = program;
      return program;
    },
    // gather functions
    namedGather: function(map, element) {
      map = map || {};
      map[element.name] = element;
      return map;
    },
    // gather a list of elements
    gather: function(list, element) {
      list = list || [];
      list.push(element);
      return list;
    },
    // conditionals
    if_: function(cond, block, elses) {
      if (elses != null) {
        elses.conds.unshift(cond);
        elses.blocks.unshift(block);
      } else {
        return new TAPE.node.If([cond], [block]);
      }
      return new TAPE.node.If(elses.conds, elses.blocks);
    },
    elseif: function(cond, block, elses) {
      if (elses == null) {
        return {
          conds: [cond],
          blocks: [block]
        };
      } else {
        elses.conds.unshift(cond);
        elses.blocks.unshift(block);
      }
      return elses;
    },
    else_: function(block) {
      return {
        conds: [true],
        blocks: [block]
      };
    },
    callDyadic: function(name, params, param) {
      var fullList;
      fullList = this.callDyadicList(name, params, param);
      delete params.name;
      return new TAPE.node.Call(name, params);
    },
    callDyadicList: function(name, params, param) {
      var newList;
      if (params instanceof Array) { // list of params
        if (params.name === name) { // same operator
          params.push(param);
          return params; // different operators
        } else {
          newList = [new TAPE.node.Call(params.name, params), param];
          delete params.name;
          newList.name = name;
          return newList; // single param
        }
      } else {
        newList = [params, param];
        newList.name = name;
        return newList;
      }
    },
    loop: function(type, cond, block) {
      var lp;
      lp = new TAPE.node.Loop(cond, block, type);
      // find breaks recursively
      find_breaks(lp, block);
      return lp;
    },
    // parse number
    number: function(type, value) {
      var val;
      val = value.substring(2);
      switch (type) {
        case "decimal":
          return parseInt(value);
        case "octal":
          return parseInt(val, 8);
        case "hexadecimal":
          return parseInt(val, 16);
        case "binary":
          return parseInt(val, 2);
        case "character":
          return value.charCodeAt(1);
        default:
          return 0;
      }
    }
  };

  // helper function to find breaks recursively
  find_breaks = function(lp, block) {
    var b, instr, j, len, results;
    results = [];
    for (j = 0, len = block.length; j < len; j++) {
      instr = block[j];
      if (instr === TAPE.node.If) {
        results.push((function() {
          var k, len1, ref, results1;
          ref = instr.blocks;
          results1 = [];
          for (k = 0, len1 = ref.length; k < len1; k++) {
            b = ref[k];
            results1.push(find_breaks(lp.loopType, b));
          }
          return results1;
        })());
      } else if (instr === TAPE.node.Break && instr.loopType === lp.loopType) {
        results.push(instr.loop = lp);
      } else if (instr === TAPE.node.Loop && instr.loopType !== lp.loopType) {
        results.push(find_breaks(lp.loopType, instr.block));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  memory = {};

  memory.Register = class Register {
    constructor(type) {
      // array : store the data
      // byte  : keep number in the expected range
      // index : index the array
      if (type === 16) {
        this.array = new Int16Array(16);
        this.type = 16;
      } else {
        this.array = new Int8Array(8);
        this.type = 8;
      }
    }

    // access the array
    get(i) {
      return this.array[TAPE.corrector.unsign(i) % this.type];
    }

    set(i, x) {
      i = TAPE.corrector.unsign(i) % this.type;
      return this.array[i] = x;
    }

    incr(i) {
      i = TAPE.corrector.unsign(i) % this.type;
      return ++this.array[i];
    }

    decr(i) {
      i = TAPE.corrector.unsign(i) % this.type;
      return --this.array[i];
    }

    repl(i, x, op) {
      i = TAPE.corrector.unsign(i) % this.type;
      return this.array[i] = op(this.array[i], x);
    }

  };

  memory.Tape = class Tape {
    constructor(type) {
      // array : store the data
      // byte  : keep number in the expected range
      // index : index the array
      if (type === 16) {
        this.array = new Int16Array(0x10000);
        this.type = 16;
      } else {
        this.array = new Int8Array(0x100);
        this.type = 8;
      }
    }

    // make a register for a function
    makeReg(params) {
      var i, j, length, ref, ref1, reg;
      reg = new memory.Register(this.type);
      length = Math.min(this.type, (ref = params != null ? params.length : void 0) != null ? ref : 0);
      for (i = j = 0, ref1 = length; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
        reg.set(i, params[i]);
      }
      return reg;
    }

    // access the array
    get(i) {
      return this.array[TAPE.corrector.unsign(i)];
    }

    set(i, x) {
      i = TAPE.corrector.unsign(i);
      this.array[i] = x;
      return typeof TAPE.updateCell === "function" ? TAPE.updateCell(i, x) : void 0;
    }

    incr(i) {
      i = TAPE.corrector.unsign(i);
      return typeof TAPE.updateCell === "function" ? TAPE.updateCell(i, ++this.array[i]) : void 0;
    }

    decr(i) {
      i = TAPE.corrector.unsign(i);
      return typeof TAPE.updateCell === "function" ? TAPE.updateCell(i, --this.array[i]) : void 0;
    }

    repl(i, x, op) {
      var y;
      i = TAPE.corrector.unsign(i);
      y = op(this.array[i], x);
      this.array[i] = y;
      return typeof TAPE.updateCell === "function" ? TAPE.updateCell(i, y) : void 0;
    }

  };

  node = {};

  // classes that define the nodes of our AST
  Node = class Node {
    link() {
      return console.log("not implemented");
    }

    run() {
      return console.log("not implemented");
    }

    string(tabs) {
      return str_tabs(tabs) + "[UNDEFINED!]\n";
    }

  };

  // helper functions to print the AST
  str_tabs = function(tabs) {
    var j, ref, str;
    str = "";
    for (j = 0, ref = tabs; (0 <= ref ? j < ref : j > ref); 0 <= ref ? j++ : j--) {
      str += '\t';
    }
    return str;
  };

  str_block = function(tabs, block) {
    var e, j, len, str;
    str = "";
    for (j = 0, len = block.length; j < len; j++) {
      e = block[j];
      str += e.string(tabs);
    }
    return str;
  };

  str_node = function(tabs, n) {
    var ref;
    return (ref = typeof n.string === "function" ? n.string(tabs) : void 0) != null ? ref : str_tabs(tabs + n + "\n");
  };

  /* AST NODES */
  /* Base */
  // program
  node.Program = class Program extends Node {
    constructor(def1, funcs1) {
      var name;
      super();
      this.def = def1;
      this.funcs = funcs1;
      // correct the definition if there was an error
      if (this.def !== 8 && this.def !== 16) {
        this.def = 8;
      }
      // generate a new tape using the definition provided
      this.tape = new TAPE.memory.Tape(this.def);
// provide a pointer to the program to every node of the tree
      for (name in this.funcs) {
        this.funcs[name].link(this);
      }
    }

    run(params) {
      return this.funcs[null].run(params);
    }

    string(tabs) {
      return `PROGRAM ${this.def}:\n` + str_block(0, this.funcs);
    }

  };

  // declare a function
  node.Function = class Function extends Node {
    constructor(name1, block1) {
      super();
      this.name = name1;
      this.block = block1;
      this.returnValue = 0;
    }

    link(program1) {
      var instr, j, len, ref;
      this.program = program1;
      ref = this.block;
      for (j = 0, len = ref.length; j < len; j++) {
        instr = ref[j];
        if (typeof instr.link === "function") {
          instr.link(this.program, this);
        }
      }
      return null;
    }

    async run(params) {
      var instr, j, len, ref, reg;
      // generate a register for the function
      reg = this.program.tape.makeReg(params);
      ref = this.block;
      // execute instructions
      for (j = 0, len = ref.length; j < len; j++) {
        instr = ref[j];
        await instr.run(reg);
      }
      return this.returnValue;
    }

    string(tabs) {
      var str;
      // print function name and content
      str = this.name !== null ? `FUNCTION ${this.name}:\n` : "MAIN FUNCTION:\n";
      str += str_block(tabs, this.block);
      return str;
    }

  };

  node.Return = class Return extends Node {
    constructor(val1) {
      super();
      this.val = val1;
      this.func = null;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.val).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      var base, ref;
      return this.func.returnValue = (ref = (await (typeof (base = this.val).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.val;
    }

    string(tabs) {
      return str_tabs(tabs) + "RETURN:\n" + str_node(tabs + 1, this.val);
    }

  };

  // access a variable
  node.Variable = class Variable extends Node {
    constructor(useReg, ind) {
      super();
      this.useReg = useReg;
      this.ind = ind;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.ind).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async index(reg) {
      var base, ref;
      return (ref = (await (typeof (base = this.ind).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.ind;
    }

    async run(reg) {
      return (await this.get(reg));
    }

    async get(reg) { // get the value of the variable
      var index;
      index = (await this.index(reg));
      if (this.useReg) {
        return reg.get(index);
      } else {
        return this.program.tape.get(index);
      }
    }

    async set(reg, val) {
      var index;
      index = (await this.index(reg));
      if (this.useReg) {
        reg.set(index, val);
      } else {
        this.program.tape.set(index, val);
      }
      return null;
    }

    async incr(reg) {
      var index;
      index = (await this.index(reg));
      if (this.useReg) {
        reg.incr(index);
      } else {
        this.program.tape.incr(index);
      }
      return null;
    }

    async decr(reg) {
      var index;
      index = (await this.index(reg));
      if (this.useReg) {
        reg.decr(index);
      } else {
        this.program.tape.decr(index);
      }
      return null;
    }

    async repl(reg, val, op) {
      var index;
      index = (await this.index(reg));
      if (this.useReg) {
        reg.repl(index, val, op);
      } else {
        this.program.tape.repl(index, val, op);
      }
      return null;
    }

    async set_str(reg, text) { // special set value for strings
      var array, i, index, j, ref, results;
      index = (await this.index(reg));
      array = this.useReg ? reg : this.program.tape;
      results = [];
      for (i = j = 0, ref = text.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        results.push(array.set(index + i, text.charCodeAt(i)));
      }
      return results;
    }

    string(tabs) {
      var str;
      str = stringTabs(tabs) + (this.useReg ? "REGISTER:\n" : "TAPE:\n");
      return str + str_node(tabs + 1, this.ind);
    }

  };

  /* Assignements */
  // change the value of a cell
  node.Assign = class Assign extends Node {
    constructor(_var, val1) {
      super();
      this.var = _var;
      this.val = val1;
    }

    link(program1, func) {
      var base, base1;
      this.program = program1;
      this.func = func;
      if (typeof (base = this.var).link === "function") {
        base.link(this.program, this.func);
      }
      return typeof (base1 = this.val).link === "function" ? base1.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      var base, ref, val;
      val = (ref = (await (typeof (base = this.val).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.val;
      return this.var.set(reg, val);
    }

    string(tabs) {
      return str_tabs(tabs) + "IN:\n" + str_node(tabs + 1, this.var) + str_tabs(tabs) + "PUT:\n" + str_node(tabs + 1, this.val);
    }

  };

  node.SelfAssign = class SelfAssign extends Node {
    constructor(_var, val1, op1) {
      super();
      this.var = _var;
      this.val = val1;
      this.op = op1;
    }

    link(program1, func) {
      var base, base1;
      this.program = program1;
      this.func = func;
      if (typeof (base = this.var).link === "function") {
        base.link(this.program, this.func);
      }
      return typeof (base1 = this.val).link === "function" ? base1.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      var base, ref, val;
      val = (ref = (await (typeof (base = this.val).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.val;
      return this.var.repl(reg, val, this.op);
    }

    string(tabs) {
      return str_tabs(tabs) + "CHANGE:\n" + this.var.string(tabs + 1) + str_tabs(tabs) + `BY ${op.getName(this.op)}:\n` + this.val.string(tabs + 1);
    }

  };

  node.Increment = class Increment extends Node {
    constructor(_var) {
      super();
      this.var = _var;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.var).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      return (await this.var.incr(reg));
    }

    string(tabs) {
      return str_tabs(tabs) + "INCREMENT:\n" + this.var.string(tabs + 1);
    }

  };

  node.Decrement = class Decrement extends Node {
    constructor(_var) {
      super();
      this.var = _var;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.var).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      return (await this.var.decr(reg));
    }

    string(tabs) {
      return str_tabs(tabs) + "DECREMENT:\n" + this.var.string(tabs + 1);
    }

  };

  node.StringAssign = class StringAssign extends Node {
    constructor(_var, text1) {
      super();
      this.var = _var;
      this.text = text1;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.var).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      return (await this.var.set_str(reg, this.text));
    }

    string(tabs) {
      return str_tabs(tabs) + `ASSIGN STRING '${text}':\n` + this.var.string(tabs + 1);
    }

  };

  /* Control flow */
  // conditional
  node.If = class If extends Node {
    constructor(conds, blocks) {
      super();
      this.conds = conds;
      this.blocks = blocks;
      if (this.conds.length !== this.blocks.length) {
        console.log("error in if statement");
      }
    }

    link(program1, func) {
      var block, cond, instr, j, k, len, len1, ref, ref1, results;
      this.program = program1;
      this.func = func;
      ref = this.conds;
      for (j = 0, len = ref.length; j < len; j++) {
        cond = ref[j];
        if (typeof cond.link === "function") {
          cond.link(this.program, this.func);
        }
      }
      ref1 = this.blocks;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        block = ref1[k];
        if (block != null) {
          results.push((function() {
            var len2, m, results1;
            results1 = [];
            for (m = 0, len2 = block.length; m < len2; m++) {
              instr = block[m];
              results1.push(typeof instr.link === "function" ? instr.link(this.program, this.func) : void 0);
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    async run(reg) {
      var block, cond, i, instr, j, len, ref, results, val;
      i = 0;
      results = [];
      while (i < this.conds.length) {
        cond = this.conds[i];
        block = this.blocks[i++];
        val = (ref = (await (typeof cond.run === "function" ? cond.run(reg) : void 0))) != null ? ref : cond;
        if (val !== 0) {
          if (block != null) {
            for (j = 0, len = block.length; j < len; j++) {
              instr = block[j];
              await instr.run(reg);
            }
            break;
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    string(tabs) {
      var block, cond, i, str;
      str = str_tabs(tabs) + "IF:\n";
      i = 0;
      while (i < this.conds.length) {
        cond = this.conds[i];
        block = this.blocks[i++];
        if (cond !== true) { // condition declared
          str += str_tabs(tabs + 1) + "ON CONDITION:\n" + cond.string(tabs + 2) + str_tabs(tabs + 1) + "DO:\n"; // no condition
        } else {
          str += str_tabs(tabs + 1) + "NO CONDITION DO:\n";
        }
        str += str_block(tabs + 2, block);
      }
      return str;
    }

  };

  // loop
  node.Loop = class Loop extends Node {
    constructor(cond1, block1, loopType) {
      super();
      this.cond = cond1;
      this.block = block1;
      this.loopType = loopType;
      this.stopLoop = 0;
    }

    link(program1, func) {
      var base, instr, j, len, ref, results;
      this.program = program1;
      this.func = func;
      if (typeof (base = this.cond).link === "function") {
        base.link(this.program, this.func);
      }
      ref = this.block;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        instr = ref[j];
        results.push(typeof instr.link === "function" ? instr.link(this.program, this.func) : void 0);
      }
      return results;
    }

    async run(reg) {
      var base, base1, instr, j, len, ref, ref1, ref2, val;
      val = (ref = (await (typeof (base = this.cond).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.cond;
      while (val !== 0) {
        ref1 = this.block;
        for (j = 0, len = ref1.length; j < len; j++) {
          instr = ref1[j];
          await (typeof instr.run === "function" ? instr.run(reg) : void 0);
          if (this.stopLoop !== 0) {
            break;
          }
        }
        if (this.stopLoop === 1) {
          continue;
        } else if (this.stopLoop === -1) {
          break;
        }
        val = (ref2 = (await (typeof (base1 = this.cond).run === "function" ? base1.run(reg) : void 0))) != null ? ref2 : this.cond;
      }
      return this.stopLoop = 0; // does it work with recursive function call ?
    }

    string(tabs) {
      if (cond !== null) {
        return str_tabs(tabs) + "LOOP WHILE:\n" + this.cond.string(tabs + 1) + str_tabs(tabs) + "DO:\n" + this.block.string(tabs + 1);
      } else {
        return str_tabs(tabs) + "LOOP:\n" + this.block.string(tabs + 1);
      }
    }

  };

  node.Break = class Break extends Node {
    constructor(isStop, loopType) {
      super();
      this.isStop = isStop;
      this.loopType = loopType;
      this.loop = null;
    }

    link(program1, func) {
      this.program = program1;
      this.func = func;
      return null;
    }

    run(reg) {
      return this.loop.stopLoop = this.isStop ? -1 : 1;
    }

    string(tabs) {
      return str_tabs(tabs) + "BREAK " + (this.isStop ? "▼" : "▲");
    }

  };

  /* Operations */
  // call function
  node.Call = class Call extends Node {
    constructor(name1, params1) {
      super();
      this.name = name1;
      this.params = params1;
      this.params = this.params || [];
      this.call = null;
    }

    // prepare a pointer to the function to call
    // reduce a part of the AST if useless
    link(program1, func) {
      var j, len, name, param, ref, results;
      this.program = program1;
      this.func = func;
      for (name in this.program.funcs) {
        if (name === this.name) {
          this.call = this.program.funcs[name];
        }
      }
      if (this.call == null) {
        console.log(`function ${this.name} not found !`);
      }
      this.params.splice(this.program.def, this.params.length);
      ref = this.params;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        param = ref[j];
        results.push(typeof param.link === "function" ? param.link(this.program, this.func) : void 0);
      }
      return results;
    }

    async run(reg) {
      var base;
      return (await (typeof (base = this.call).run === "function" ? base.run(this.params) : void 0));
    }

    string(tabs) {
      return str_tabs(tabs) + `CALL ${this.name} WITH PARAMS:\n` + str_block(tabs + 1, this.params);
    }

  };

  // apply operations to values
  node.Monadic = class Monadic extends Node {
    constructor(op1, expr) {
      super();
      this.op = op1;
      this.expr = expr;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.expr).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      var base, ref, val;
      val = (ref = (await (typeof (base = this.expr).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.expr;
      return this.op(val);
    }

    string(tabs) {
      return str_tabs(tabs) + `MONADIC ${TAPE.op.getName(this.op)}:\n` + this.expr.string(tabs + 1);
    }

  };

  node.Dyadic = class Dyadic extends Node {
    constructor(op1, left1, right1) {
      super();
      this.op = op1;
      this.left = left1;
      this.right = right1;
    }

    link(program1, func) {
      var base, base1;
      this.program = program1;
      this.func = func;
      if (typeof (base = this.left).link === "function") {
        base.link(this.program, this.func);
      }
      return typeof (base1 = this.right).link === "function" ? base1.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      var base, base1, left, ref, ref1, right;
      left = (ref = (await (typeof (base = this.left).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.left;
      right = (ref1 = (await (typeof (base1 = this.right).run === "function" ? base1.run(reg) : void 0))) != null ? ref1 : this.right;
      return this.op(left, right);
    }

    string(tabs) {
      return str_tabs(tabs) + `DYADIC ${TAPE.op.getName(this.op)}:\n` + str_tabs(tabs + 1) + "LEFT:\n" + strExpr(tabs + 2, this.left) + str_tabs(tabs + 1) + "RIGHT:\n" + strExpr(tabs + 2, this.right);
    }

  };

  // do an action
  node.Action = class Action extends Node {
    constructor(act, val1) {
      super();
      this.act = act;
      this.val = val1;
    }

    link(program1, func) {
      var base;
      this.program = program1;
      this.func = func;
      return typeof (base = this.val).link === "function" ? base.link(this.program, this.func) : void 0;
    }

    async run(reg) {
      var base, ref, val;
      val = (ref = (await (typeof (base = this.val).run === "function" ? base.run(reg) : void 0))) != null ? ref : this.val;
      return (await this.act(val));
    }

    string(tabs) {
      var name;
      name = (function() {
        switch (this.act) {
          case TAPE.action.wait:
            return "WAIT";
          case TAPE.action.bell:
            return "BELL";
          case TAPE.action.print:
            return "PRINT";
        }
      }).call(this);
      return str_tabs(tabs) + `ACTION ${name}:\n` + this.var.string(tabs + 1);
    }

  };

  op = {
    getName: function(fun) {
      var fun2, name;
      if ((function() {
        var ref, results;
        ref = this;
        results = [];
        for (name in ref) {
          fun2 = ref[name];
          results.push(fun2 === fun);
        }
        return results;
      }).call(this)) {
        return name;
      }
    },
    // unary
    not_: function(a) {
      if (!a) {
        return 0;
      } else {
        return 1;
      }
    },
    bnot: function(a) {
      return TAPE.corrector.sign(~a);
    },
    abs: function(a) {
      return TAPE.corrector.sign(Math.abs(a)); // special case |-128| -> 128 > 127 -> -128
    },
    neg: function(a) {
      return TAPE.corrector.sign(-a); // we may have only positive numbers
    },
    
    // arithmetic
    add: function(a, b) {
      return TAPE.corrector.sign(a + b);
    },
    sub: function(a, b) {
      return TAPE.corrector.sign(a - b);
    },
    mul: function(a, b) {
      return TAPE.corrector.sign(a * b);
    },
    div: function(a, b) {
      return TAPE.corrector.sign(Math.floor(a / b)); // if b == 0 -> 0
    },
    mod: function(a, b) {
      return TAPE.corrector.sign(modulo(a, b));
    },
    // logical
    and_: function(a, b) {
      if (a && b) {
        return 1;
      } else {
        return 0;
      }
    },
    nand: function(a, b) {
      if (a && b) {
        return 0;
      } else {
        return 1;
      }
    },
    or_: function(a, b) {
      if (a || b) {
        return 1;
      } else {
        return 0;
      }
    },
    nor: function(a, b) {
      if (a || b) {
        return 0;
      } else {
        return 1;
      }
    },
    xor: function(a, b) {
      if (!a !== !b) {
        return 1;
      } else {
        return 0;
      }
    },
    xnor: function(a, b) {
      if (!a !== !b) {
        return 0;
      } else {
        return 1;
      }
    },
    // bitwise
    band: function(a, b) {
      return TAPE.corrector.sign(a & b);
    },
    bor: function(a, b) {
      return TAPE.corrector.sign(a | b);
    },
    bxor: function(a, b) {
      return TAPE.corrector.sign(a ^ b);
    },
    bnand: function(a, b) {
      return TAPE.corrector.sign(~(a & b));
    },
    bnor: function(a, b) {
      return TAPE.corrector.sign(~(a | b));
    },
    bxnor: function(a, b) {
      return TAPE.corrector.sign(~(a ^ b));
    },
    lshift: function(a, b) {
      return TAPE.corrector.sign(a << b);
    },
    rshift: function(a, b) {
      return TAPE.corrector.sign(a >> b);
    },
    // comparator
    equ: function(a, b) {
      if (a === b) {
        return 1;
      } else {
        return 0;
      }
    },
    dif: function(a, b) {
      if (a !== b) {
        return 1;
      } else {
        return 0;
      }
    },
    grt: function(a, b) {
      if (a > b) {
        return 1;
      } else {
        return 0;
      }
    },
    lst: function(a, b) {
      if (a < b) {
        return 1;
      } else {
        return 0;
      }
    },
    gte: function(a, b) {
      if (a >= b) {
        return 1;
      } else {
        return 0;
      }
    },
    lte: function(a, b) {
      if (a <= b) {
        return 1;
      } else {
        return 0;
      }
    }
  };

  /* TAPE */
  // store our functions into the global scope
  GLOBAL = typeof exports !== "undefined" && exports !== null ? exports : this;

  GLOBAL.TAPE = {action, corrector, formater, memory, node, op};

  /*
	Callbacks that can be implemented:

	playSound(pitch)         : to play a sound at given pitch
	printChar(charCode)      : to print the character to the console
	updateCell(index, value) : change the value of cell
*/

}).call(this);
